use std::path::{Path, PathBuf};
use std::process::Command;

fn main() {
    if std::env::var("CARGO_FEATURE_STATIC").is_ok() {
        if cfg!(target_os = "windows") {
            panic!("odbc-sys does not currently support static linking on windows");
        }

        // When the static feature is enabled, compile the ODBC driver manager from source
        compile_odbc_from_source();
    }

    if cfg!(target_os = "macos") {
        if let Some(homebrew_lib_path) = homebrew_library_path() {
            print_paths(&homebrew_lib_path);
        }

        // if we're on Mac OS X we'll kindly add DYLD_LIBRARY_PATH to rustc's
        // linker search path
        if let Some(dyld_paths) = option_env!("DYLD_LIBRARY_PATH") {
            print_paths(dyld_paths);
        }
        // if we're on Mac OS X we'll kindly add DYLD_FALLBACK_LIBRARY_PATH to rustc's
        // linker search path
        if let Some(dyld_fallback_paths) = option_env!("DYLD_FALLBACK_LIBRARY_PATH") {
            print_paths(dyld_fallback_paths);
        }
    }
}

fn compile_odbc_from_source() {
    let use_iodbc = std::env::var("CARGO_FEATURE_IODBC").is_ok();
    
    if use_iodbc {
        compile_iodbc();
    } else {
        compile_unixodbc();
    }
}

fn ensure_configured(vendor_dir: &Path) -> std::io::Result<()> {
    let config_h = vendor_dir.join("config.h");
    let configure_script = vendor_dir.join("configure");
    
    // Check if config.h already exists
    if config_h.exists() {
        return Ok(());
    }
    
    // Check if configure script exists
    if !configure_script.exists() {
        // Try to run autogen.sh if it exists
        let autogen = vendor_dir.join("autogen.sh");
        if autogen.exists() {
            println!("cargo:warning=Running autogen.sh for {:?}", vendor_dir);
            let status = Command::new("sh")
                .arg(&autogen)
                .current_dir(vendor_dir)
                .status();
            
            if let Ok(status) = status {
                if !status.success() {
                    println!("cargo:warning=autogen.sh failed, will try to continue");
                }
            }
        }
    }
    
    // Run configure if it exists
    if configure_script.exists() {
        println!("cargo:warning=Running configure for {:?}", vendor_dir);
        let out_dir = std::env::var("OUT_DIR").unwrap();
        let prefix = PathBuf::from(&out_dir).join("odbc_install");
        
        let status = Command::new(&configure_script)
            .arg("--disable-gui")
            .arg("--disable-drivers")
            .arg("--enable-static")
            .arg("--disable-shared")
            .arg(format!("--prefix={}", prefix.display()))
            .current_dir(vendor_dir)
            .status();
        
        if let Ok(status) = status {
            if !status.success() {
                println!("cargo:warning=configure failed, attempting to create minimal config.h");
                create_minimal_config_h(vendor_dir)?;
            }
        } else {
            println!("cargo:warning=Failed to execute configure, creating minimal config.h");
            create_minimal_config_h(vendor_dir)?;
        }
    } else {
        println!("cargo:warning=No configure script found, creating minimal config.h");
        create_minimal_config_h(vendor_dir)?;
    }
    
    Ok(())
}

fn create_minimal_config_h(vendor_dir: &Path) -> std::io::Result<()> {
    let config_h = vendor_dir.join("config.h");
    
    let config_content = r#"/* Minimal config.h generated by build.rs */
#ifndef _CONFIG_H
#define _CONFIG_H

/* Define standard headers */
#define HAVE_STDLIB_H 1
#define HAVE_STRING_H 1
#define HAVE_UNISTD_H 1
#define HAVE_PWD_H 1
#define HAVE_SYS_TYPES_H 1
#define HAVE_STDARG_H 1
#define HAVE_TIME_H 1
#define HAVE_ERRNO_H 1
#define HAVE_MALLOC_H 1
#define HAVE_DLFCN_H 1
#define HAVE_CTYPE_H 1
#define HAVE_LIMITS_H 1
#define HAVE_PTHREAD_H 1

/* Define standard functions */
#define HAVE_LONG_LONG 1
#define HAVE_STRTOL 1
#define HAVE_STRTOLL 1
#define HAVE_ATOLL 1
#define HAVE_STRNCASECMP 1
#define HAVE_VSNPRINTF 1
#define HAVE_SNPRINTF 1
#define HAVE_STRCASECMP 1
#define HAVE_STRDUP 1
#define HAVE_SETLOCALE 1
#define HAVE_MEMSET 1
#define HAVE_MEMCPY 1
#define HAVE_PUTENV 1
#define HAVE_STRERROR 1
#define HAVE_LOCALTIME_R 1

/* Type sizes */
#if defined(__LP64__) || defined(_WIN64)
#define SIZEOF_LONG_INT 8
#else
#define SIZEOF_LONG_INT 4
#endif

/* Threading support */
#define HAVE_LIBPTHREAD 1

/* Dynamic loading */
#define HAVE_LIBDL 1

/* Package info */
#define PACKAGE "unixODBC"
#define VERSION "2.3.12"

/* Platform detection */
#ifdef __linux__
#define PLATFORM_LINUX 1
#endif

#ifdef __APPLE__
#define PLATFORM_MACOS 1
#endif

/* ODBC settings */
#define ENABLE_UNICODE_SUPPORT 1
#define SQL_WCHART_CONVERT 1

#endif /* _CONFIG_H */
"#;
    
    std::fs::write(&config_h, config_content)?;
    println!("cargo:warning=Created minimal config.h at {:?}", config_h);
    Ok(())
}

fn compile_unixodbc() {
    let vendor_dir = Path::new("vendor/unixODBC");
    
    // Ensure config.h exists
    if let Err(e) = ensure_configured(vendor_dir) {
        println!("cargo:warning=Failed to configure unixODBC: {}", e);
    }
    
    let mut build = cc::Build::new();
    
    // Add include paths
    build.include(vendor_dir.join("include"));
    build.include(vendor_dir.join("DriverManager"));
    build.include(vendor_dir.join("odbcinst"));
    build.include(vendor_dir.join("ini"));
    build.include(vendor_dir.join("log"));
    build.include(vendor_dir.join("lst"));
    build.include(vendor_dir);
    
    // Add common compiler flags
    build.flag_if_supported("-fPIC");
    build.flag_if_supported("-w"); // Suppress warnings from vendor code
    
    // Define common macros
    build.define("HAVE_CONFIG_H", None);
    
    // Collect all source files from DriverManager
    let driver_manager_dir = vendor_dir.join("DriverManager");
    add_c_files(&mut build, &driver_manager_dir);
    
    // Collect all source files from odbcinst
    let odbcinst_dir = vendor_dir.join("odbcinst");
    add_c_files(&mut build, &odbcinst_dir);
    
    // Collect all source files from ini
    let ini_dir = vendor_dir.join("ini");
    add_c_files(&mut build, &ini_dir);
    
    // Collect all source files from log
    let log_dir = vendor_dir.join("log");
    add_c_files(&mut build, &log_dir);
    
    // Collect all source files from lst
    let lst_dir = vendor_dir.join("lst");
    add_c_files(&mut build, &lst_dir);
    
    // Compile the library
    build.compile("odbc");
    
    // Link additional dependencies
    if cfg!(target_os = "macos") {
        println!("cargo:rustc-link-lib=dylib=iconv");
    }
    println!("cargo:rustc-link-lib=pthread");
    println!("cargo:rustc-link-lib=dl");
    
    println!("cargo:rerun-if-changed=vendor/unixODBC");
}

fn compile_iodbc() {
    let vendor_dir = Path::new("vendor/iODBC");
    
    // Ensure config.h exists
    if let Err(e) = ensure_configured(vendor_dir) {
        println!("cargo:warning=Failed to configure iODBC: {}", e);
    }
    
    let mut build = cc::Build::new();
    
    // Add include paths
    build.include(vendor_dir.join("include"));
    build.include(vendor_dir.join("iodbc"));
    build.include(vendor_dir.join("iodbcinst"));
    build.include(vendor_dir);
    
    // Add common compiler flags
    build.flag_if_supported("-fPIC");
    build.flag_if_supported("-w"); // Suppress warnings from vendor code
    
    // Define common macros for iODBC
    build.define("HAVE_CONFIG_H", None);
    
    // Collect all source files from iodbc
    let iodbc_dir = vendor_dir.join("iodbc");
    add_c_files(&mut build, &iodbc_dir);
    
    // Collect all source files from iodbcinst
    let iodbcinst_dir = vendor_dir.join("iodbcinst");
    add_c_files(&mut build, &iodbcinst_dir);
    
    // Compile the library
    build.compile("iodbc");
    
    // Link pthread for iODBC
    println!("cargo:rustc-link-lib=pthread");
    println!("cargo:rustc-link-lib=dl");
    
    if cfg!(target_os = "macos") {
        println!("cargo:rustc-link-lib=dylib=iconv");
    }
    
    println!("cargo:rerun-if-changed=vendor/iODBC");
}

fn add_c_files(build: &mut cc::Build, dir: &Path) {
    if !dir.exists() {
        return;
    }
    
    let entries = match std::fs::read_dir(dir) {
        Ok(entries) => entries,
        Err(_) => return,
    };
    
    for entry in entries.flatten() {
        let path = entry.path();
        if path.is_file() {
            if let Some(ext) = path.extension() {
                if ext == "c" {
                    // Skip certain files that shouldn't be compiled
                    let filename = path.file_name().unwrap().to_str().unwrap();
                    
                    // Skip test files, utilities, and GUI components
                    if filename.starts_with("test") || 
                       filename == "dltest.c" ||
                       filename == "isql.c" ||
                       filename == "iusql.c" ||
                       filename == "odbcinst.c" ||
                       filename == "odbc-config.c" ||
                       filename == "slencheck.c" ||
                       // Skip iODBC trace files (optional GUI components)
                       filename.contains("trace") ||
                       path.to_str().unwrap().contains("/trace/") {
                        continue;
                    }
                    
                    build.file(&path);
                }
            }
        }
    }
}

fn print_paths(paths: &str) {
    for path in paths.split(':').filter(|x| !x.is_empty()) {
        println!("cargo:rustc-link-search=native={path}")
    }
}

fn homebrew_library_path() -> Option<String> {
    let output = Command::new("brew").arg("--prefix").output().ok()?;
    if !output.status.success() {
        return None;
    }
    let prefix =
        String::from_utf8(output.stdout).expect("brew --prefix must yield utf8 encoded response");
    // brew returns also a linebreak (`\n`), we want to get rid of that.
    let prefix = prefix.trim();
    let lib_path = prefix.to_owned() + "/lib";
    Some(lib_path)
}
